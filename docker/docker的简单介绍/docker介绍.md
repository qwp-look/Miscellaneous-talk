# Docker 全面介绍

## 🐳 什么是 Docker？

Docker 是一个开源的容器化平台，允许开发者将应用及其依赖打包到一个轻量级、可移植的容器中。

## ⚙️ 核心功能

### 容器化技术
- **应用隔离** - 每个容器运行在独立的环境中
- **依赖管理** - 包含应用运行所需的所有依赖
- **环境一致性** - 开发、测试、生产环境保持一致

### 镜像管理
- **分层存储** - 镜像采用分层结构，提高存储效率
- **版本控制** - 支持镜像版本管理和回滚
- **仓库分发** - 通过 Docker Hub 等平台分享镜像

### 编排与部署
- **多容器管理** - 使用 Docker Compose 管理多个容器
- **集群部署** - 通过 Swarm 或 Kubernetes 进行集群部署
- **服务发现** - 自动服务注册和发现机制

## 🔧 基本用法

### 安装 Docker
```bash
# Ubuntu 安装示例
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
```

# 常用命令
```markdown
#### 拉取镜像
docker pull nginx:latest

#### 运行容器
docker run -d -p 80:80 --name my-nginx nginx

#### 查看运行中的容器
docker ps

#### 查看所有容器
docker ps -a

#### 进入容器
docker exec -it my-nginx bash

#### 停止容器
docker stop my-nginx

#### 删除容器
docker rm my-nginx

#### 查看镜像
docker images

#### 构建镜像
docker build -t my-app .
```

# Dockerfile 示例

```Dockerfile
FROM node:14-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```
# 🏗️ 工作原理
### 架构组成
```
+--------------------------------+
|        Docker Client           |
+--------------------------------+
|        Docker Daemon           |
+--------------------------------+
|   Containerd                   |
+--------------------------------+
|   RunC                         |
+--------------------------------+
|   Linux Kernel                 |
|   (Namespaces, Cgroups, etc.)  |
+--------------------------------+
```
# 核心技术
1. 命名空间 (Namespaces)
```
PID 命名空间 - 进程隔离

Network 命名空间 - 网络栈隔离

Mount 命名空间 - 文件系统隔离

UTS 命名空间 - 主机名隔离

IPC 命名空间 - 进程间通信隔离

User 命名空间 - 用户权限隔离
```
2. 控制组 (Cgroups)
```
资源限制 - CPU、内存、磁盘 I/O 限制

优先级设置 - 资源使用优先级

资源统计 - 资源使用情况监控

进程控制 - 进程挂起、恢复
```
3. 联合文件系统 (UnionFS)
```
分层结构 - 镜像和容器使用分层文件系统

写时复制 - 多个容器共享基础镜像层

存储驱动 - overlay2、aufs、devicemapper 等
```

# 容器 vs 虚拟机

**这仅仅是我的个人观点**
```markdown
**虚拟机**
 虚拟化的是整个计算机，包括硬件（CPU、内存、硬盘、网卡等）。它在物理服务器上运行一个完整的“客户”操作系统。
**容器**
虚拟化的是操作系统。它们共享主机的操作系统内核，但将自己的文件系统、库和应用程序打包在一个隔离的环境中。

**所以对比虚拟机的话docker的占用会小很多**
```
**剩下的是deepseek的回答了**

## 经典比喻：运输货物

### 虚拟机方案
```markdown
1. 租用货轮（**物理服务器**）
2. 安装运输集装箱（**Hypervisor**）
3. 每个集装箱包含：
   - 完整的**客户操作系统**
   - 所有依赖和库
   - 应用程序
```
### 容器方案
```markdown
1. 租用货轮（**物理服务器**）
2. 只有一个**标准的操作系统**
3. 使用容器引擎创建轻量级**货箱**
4. 每个货箱包含：
   - 应用程序
   - 精确的依赖和库
   - 共享底层操作系统内核
```

## 对比表格

| 特性 | 虚拟机 | 容器 |
| :--- | :--- | :--- |
| **虚拟化级别** | **硬件级** | **操作系统级** |
| **隔离性** | **强隔离** | **进程级隔离** |
| **性能** | 较高开销 | **近乎原生性能** |
| **镜像大小** | **非常大**（GB级别） | **非常小**（MB级别） |
| **启动速度** | **慢**（分钟级） | **极快**（秒级） |
| **可移植性** | 较好 | **极好** |
| **资源占用** | 高 | 低 |
| **典型用例** | - 运行不同OS的应用<br>- 强隔离需求<br>- 遗留系统 | - 微服务架构<br>- CI/CD流水线<br>- 云原生应用 |

## 技术代表
```markdown
### 虚拟机技术
- VMware
- Hyper-V
- KVM
- VirtualBox

### 容器技术
- **Docker**
- **containerd**
- Podman
- Kubernetes
```
## 选择指南
```markdown
### 选择虚拟机当：
1. 需要运行不同的操作系统
2. 安全性和隔离性是最高优先级
3. 运行传统的单体应用
4. 对内核有特殊需求

### 选择容器当：
1. 微服务和云原生应用
2. 高资源利用率和部署密度
3. 敏捷开发和持续部署
4. 快速扩展和缩容需求
```
